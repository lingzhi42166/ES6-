{"version":3,"sources":["..\\..\\..\\ECMAScript6\\js\\11、for of.js"],"names":["arr","key","console","log","forEach","value","set","Set","map","Map"],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAwBA;;;AAGA,IAAIA,MAAM,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,CAAV;AACA;AACA,KAAI,IAAIC,GAAR,IAAeD,GAAf,EAAmB;AACfE,YAAQC,GAAR,CAAYF,GAAZ;AACH;AACD;AACAD,IAAII,OAAJ,CAAY,UAACC,KAAD,EAAOJ,GAAP,EAAa;AACrBC,YAAQC,GAAR,CAAYE,KAAZ,EAAkBJ,GAAlB;AACH,CAFD;AAGA;;;;;;AACA,yBAAiBD,GAAjB,8HAAqB;AAAA,YAAbK,KAAa;;AACjBH,gBAAQC,GAAR,CAAYE,KAAZ;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA;;;;;;;;;;;;;;;;;;;AAIAH,QAAQC,GAAR,CAAY,iCAAZ;AACA,IAAIG,MAAM,IAAIC,GAAJ,CAAQ,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,CAAR,CAAV;AACAD,IAAIF,OAAJ,CAAY,UAACC,KAAD,EAAOJ,GAAP,EAAa;AACrBC,YAAQC,GAAR,CAAYE,KAAZ,EAAkBJ,GAAlB;AACH,CAFD;;AAIA;;;;AAIA;;;;;;AACA,0BAAiBK,GAAjB,mIAAqB;AAAA,YAAbD,MAAa;;AACjBH,gBAAQC,GAAR,CAAYE,MAAZ;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;AAMA,IAAIG,MAAM,IAAIC,GAAJ,CAAQ,CAAC,CAAC,GAAD,EAAK,CAAL,CAAD,EAAS,CAAC,GAAD,EAAK,CAAL,CAAT,CAAR,CAAV;AACAP,QAAQC,GAAR,CAAYK,GAAZ;AACAA,IAAIJ,OAAJ,CAAY,YAAU;AAAA,sCAANJ,GAAM;AAANA,WAAM;AAAA;;AAAC;AACnBE,YAAQC,GAAR,CAAYH,GAAZ;AACH,CAFD;AAGAQ,IAAIJ,OAAJ,CAAY,UAACC,KAAD,EAAOJ,GAAP,EAAa;AACrBC,YAAQC,GAAR,CAAYE,KAAZ,EAAkBJ,GAAlB;AACH,CAFD;;;;;;AAGA,0BAAiBO,GAAjB,mIAAqB;AAAA,YAAbH,OAAa;;AACjBH,gBAAQC,GAAR,CAAYE,OAAZ,EADiB,CACE;AACtB;;;;;;;;;;;;;;;;;;;;;AACD,0BAAuBG,GAAvB,mIAA2B;AAAA;AAAA,YAAlBP,KAAkB;AAAA,YAAdI,OAAc;;AACvBH,gBAAQC,GAAR,CAAYF,KAAZ,EAAgBI,OAAhB,EADuB,CACA;AAC1B","file":"11、for of.js","sourcesContent":["/* \r\n    for...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象\r\n    （比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。\r\n    一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）\r\n    原生具备 Iterator 接口的数据结构如下。\r\n        Array\r\n        Map\r\n        Set\r\n        String\r\n        TypedArray\r\n        函数的 arguments 对象\r\n        NodeList 对象\r\n\r\n\r\n        一些数据结构没有(比如对象)\r\n        凡是部署了Symbol.iterator属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。\r\n\r\n\r\n        总结:\r\n            for of 遍历数组和set的话 都是返回成员值\r\n            如果遍历的是Map的话 返回的是一个数组 分别是键名和键值\r\n*/\r\n\r\n\r\n/* \r\n    数组的遍历\r\n*/\r\nlet arr = [1,2,3];\r\n// for in 是给对象 遍历属性名的   如果遍历数组 则是获取到的是索引\r\nfor(let key in arr){\r\n    console.log(key);\r\n}\r\n// forEach 是遍历数组的  提供两个参数给回调函数  一个是数组的成员值 一个是成员索引\r\narr.forEach((value,key)=>{\r\n    console.log(value,key);\r\n})\r\n// for of 在数组的应用  返回的是 数组的成员值 如果需要获取索引 去看ES6的数组的扩展\r\nfor(let value of arr){\r\n    console.log(value);\r\n}\r\n\r\n/*\r\n    对象的遍历\r\n    好吧 现在还不知道怎么通过for of 遍历对象\r\n\r\nconsole.log(\"==========对象的遍历==========\");\r\nlet obj = {\r\n    x : 1,\r\n    y : 1,\r\n    [Symbol.iterator] : function () {\r\n        return {\r\n          next: function () {\r\n            return {\r\n              value: 1,\r\n              done: true\r\n            };\r\n          }\r\n        };\r\n    }\r\n}\r\n// for in 遍历出对象的属性\r\nfor(let key in obj){\r\n    console.log(key);\r\n}\r\n// for of在对象的应用\r\nfor(let value of obj){\r\n    console.log(value);\r\n}\r\n*/\r\n\r\n/* \r\n    set Map 的遍历\r\n    发现set的索引是从1开始的\r\n*/\r\nconsole.log(\"==========set Map 的遍历==========\");\r\nlet set = new Set([1,2,3]);\r\nset.forEach((value,key)=>{\r\n    console.log(value,key);\r\n})\r\n\r\n/* set 不能通过for in遍历\r\nfor (let key in set) {\r\n    console.log(key);\r\n} */\r\n// for of 在set的应用 返回的是set的成员值\r\nfor(let value of set){\r\n    console.log(value);\r\n}\r\n\r\n/* \r\n    通过for of 遍历 Map 结构时，返回的是一个数组，\r\n    该数组的两个成员分别为当前 Map 成员的键名和键值。\r\n\r\n    但是通过forEach返回的是 第一个参数是属性值 第二个参数是属性\r\n*/\r\nlet map = new Map([[\"x\",1],[\"y\",2]]);\r\nconsole.log(map);\r\nmap.forEach((...arr)=>{//通过包裹操作符 把可以遍历的都包裹在一个新的数组里\r\n    console.log(arr);\r\n})\r\nmap.forEach((value,key)=>{\r\n    console.log(value,key);\r\n})\r\nfor(let value of map){\r\n    console.log(value);//返回的是一个数组\r\n}\r\nfor(let [key,value] of map){\r\n    console.log(key,value);//返回的是一个数组\r\n}\r\n\r\n"]}