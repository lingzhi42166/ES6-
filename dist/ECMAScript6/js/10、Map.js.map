{"version":3,"sources":["..\\..\\..\\ECMAScript6\\js\\10、Map.js"],"names":["oDiv","document","getElementsByTagName","obj","console","log","items","map","Map","forEach","key","value","set","map1","get","arr","size","has","delete","clear","dir"],"mappings":";;;;AAAA;;;;;;;;;;;AAWA,IAAIA,OAAOC,SAASC,oBAAT,CAA8B,KAA9B,CAAX;AACA,IAAIC,MAAM,EAAV;AAGAC,QAAQC,GAAR,CAAYL,IAAZ;AACAG,IAAIH,IAAJ,IAAY,GAAZ,C,CAAgB;AAChBI,QAAQC,GAAR,CAAYF,GAAZ;;AAEA;AACA;;;AAGA;AACA,IAAMG,QAAQ,CACV,CAAC,MAAD,EAAS,IAAT,CADU,EAEV,CAAC,OAAD,EAAU,QAAV,CAFU,CAAd;AAIA,IAAMC,MAAM,IAAIC,GAAJ,EAAZ;AACAF,MAAMG,OAAN;AACI;;;;;;AAMA;AAAA;AAAA,QAAEC,GAAF;AAAA,QAAOC,KAAP;;AAAA,WAAkBJ,IAAIK,GAAJ,CAAQF,GAAR,EAAaC,KAAb,CAAlB;AAAA,CAPJ;AASAP,QAAQC,GAAR,CAAYE,GAAZ;;AAGA;;;;;;;;;;;;;;;;AAgBA,IAAIM,OAAO,IAAIL,GAAJ,EAAX;AACAK,KAAKD,GAAL,CAAS,CAAC,GAAD,CAAT,EAAe,CAAf;AACAR,QAAQC,GAAR,CAAYQ,KAAKC,GAAL,CAAS,CAAC,GAAD,CAAT,CAAZ,E,CAA6B;;AAE7B,IAAIC,MAAM,CAAC,GAAD,CAAV;AACAX,QAAQC,GAAR,CAAYQ,KAAKD,GAAL,CAASG,GAAT,EAAa,CAAb,CAAZ,E,CAA6B;AAC7BX,QAAQC,GAAR,CAAYQ,KAAKC,GAAL,CAASC,GAAT,CAAZ,E,CAA2B;AAC3BX,QAAQC,GAAR,CAAYQ,KAAKE,GAAjB,E,CAAsB;AACtB;AACAX,QAAQC,GAAR,CAAYQ,KAAKE,GAAL,CAAZ,E,CAAuB;;AAEvBX,QAAQC,GAAR,CAAYQ,KAAKG,IAAjB,E,CAAuB;AACvBZ,QAAQC,GAAR,CAAYQ,KAAKI,GAAL,CAASF,GAAT,CAAZ,EAA0BF,KAAKI,GAAL,CAAS,CAAC,GAAD,CAAT,CAA1B;AACAb,QAAQC,GAAR,CAAYQ,KAAKK,MAAL,CAAY,CAAC,GAAD,CAAZ,CAAZ;AACAd,QAAQC,GAAR,CAAYQ,KAAKM,KAAL,EAAZ;AACAf,QAAQC,GAAR,CAAYQ,IAAZ;;AAEA;;;;AAIAA,KAAKJ,OAAL,CAAa,YAAI;AACbL,YAAQC,GAAR,CAAY,CAAZ;AACH,CAFD;AAGAD,QAAQgB,GAAR,CAAYP,KAAKJ,OAAjB","file":"10、Map.js","sourcesContent":["/* \r\n    javascript的对象是键值对组成的  默认键都是字符串 即使传入的不是字符串类型的属性值\r\n    也是隐式通过toString转换成字符串形式的 \r\n    \r\n    为了解决这个问题，ES6 提供了 Map 数据结构。\r\n    它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，\r\n    各种类型的值（包括对象）都可以当作键。\r\n    也就是说，Object 结构提供了“字符串—值”的对应，\r\n    Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。\r\n    如果你需要“键值对”的数据结构，Map 比 Object 更合适。\r\n*/\r\nlet oDiv = document.getElementsByTagName(\"div\");\r\nlet obj = {\r\n\r\n}\r\nconsole.log(oDiv);\r\nobj[oDiv] = \"1\";//对象只接受字符串作为键名\r\nconsole.log(obj)\r\n\r\n// Map   可以接受数组作为参数[[],[],[]]\r\n/* let map = new Map([[\"name\", \"s\"], [\"age\", \"19\"]]);\r\nconsole.log(map); */\r\n\r\n// Map构造函数接受数组作为参数，实际上执行的是下面的算法。\r\nconst items = [\r\n    ['name', '张三'],\r\n    ['title', 'Author']\r\n];\r\nconst map = new Map();\r\nitems.forEach(\r\n    /* \r\n        forEach给回调函数提供了两个参数 第一个是成员值 第二个是成员的索引\r\n        那么当前遍历的数组的成员值是一个数组 所以我们可以通过数组解构的方式获取到数组里面的值\r\n        奇淫技巧\r\n        [key,value] = ['name', '张三']\r\n    */\r\n    ([key, value]) => map.set(key, value)\r\n);\r\nconsole.log(map);\r\n\r\n\r\n/*  \r\n    Map实例可用的属性和方法: (跟set数据结构的差不多)\r\n        size 属性\r\n            返回 Map 结构的成员总数\r\n        set(key, value) \r\n            设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。\r\n        get(key)\r\n            读取key对应的键值，如果找不到key，返回undefined。Map的键实际上是跟内存地址绑定的 所以访问必须是地址一样的\r\n        has(key)\r\n            返回一个布尔值，表示某个键是否在当前 Map 对象之中。\r\n        delete(key)\r\n            删除某个键，返回true。如果删除失败，返回false。\r\n        clear()\r\n            清除所有成员，没有返回值。\r\n\r\n*/\r\nlet map1 = new Map();\r\nmap1.set([\"a\"],1);\r\nconsole.log(map1.get([\"a\"]));//不是同一个引用地址了 这里相当于重新定义了一个数组 开辟了一个新的内存\r\n\r\nlet arr = [\"a\"];\r\nconsole.log(map1.set(arr,1));//Map的键实际上是跟内存地址绑定的\r\nconsole.log(map1.get(arr));//arr内存地址一样 所以返回1\r\nconsole.log(map1.arr);//undefined  通过.调用=> map1[\"arr\"];\r\n// console.log(map1.[\"a\"]); 语法错误\r\nconsole.log(map1[arr]);//也是不行 只能通过get 方法获取了\r\n\r\nconsole.log(map1.size);//2\r\nconsole.log(map1.has(arr),map1.has([\"a\"]));\r\nconsole.log(map1.delete([\"a\"]));\r\nconsole.log(map1.clear());\r\nconsole.log(map1);\r\n\r\n/* \r\n    可以通过forEach遍历\r\n*/\r\n\r\nmap1.forEach(()=>{\r\n    console.log(1);\r\n})\r\nconsole.dir(map1.forEach);"]}