{"version":3,"sources":["..\\..\\..\\ECMAScript6\\js\\10、Map.js"],"names":["_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","length","err","Array","isArray","Object","TypeError","oDiv","document","getElementsByTagName","obj","console","log","items","map","Map","forEach","_ref","_ref2","key","set","map1","get","size","has","delete","clear","dir"],"mappings":"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","file":"10、Map.js","sourcesContent":["\"use strict\";\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n/* \r\n    javascript的对象是键值对组成的  默认键都是字符串 即使传入的不是字符串类型的属性值\r\n    也是隐式通过toString转换成字符串形式的 \r\n    \r\n    为了解决这个问题，ES6 提供了 Map 数据结构。\r\n    它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，\r\n    各种类型的值（包括对象）都可以当作键。\r\n    也就是说，Object 结构提供了“字符串—值”的对应，\r\n    Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。\r\n    如果你需要“键值对”的数据结构，Map 比 Object 更合适。\r\n*/\nvar oDiv = document.getElementsByTagName(\"div\");\nvar obj = {};\nconsole.log(oDiv);\nobj[oDiv] = \"1\"; //对象只接受字符串作为键名\nconsole.log(obj);\n\n// Map   可以接受数组作为参数[[],[],[]]\n/* let map = new Map([[\"name\", \"s\"], [\"age\", \"19\"]]);\r\nconsole.log(map); */\n\n// Map构造函数接受数组作为参数，实际上执行的是下面的算法。\nvar items = [['name', '张三'], ['title', 'Author']];\nvar map = new Map();\nitems.forEach(\n/* \r\n    forEach给回调函数提供了两个参数 第一个是成员值 第二个是成员的索引\r\n    那么当前遍历的数组的成员值是一个数组 所以我们可以通过数组解构的方式获取到数组里面的值\r\n    奇淫技巧\r\n    [key,value] = ['name', '张三']\r\n*/\nfunction (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        value = _ref2[1];\n\n    return map.set(key, value);\n});\nconsole.log(map);\n\n/*  \r\n    Map实例可用的属性和方法: (跟set数据结构的差不多)\r\n        size 属性\r\n            返回 Map 结构的成员总数\r\n        set(key, value) \r\n            设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。\r\n        get(key)\r\n            读取key对应的键值，如果找不到key，返回undefined。Map的键实际上是跟内存地址绑定的 所以访问必须是地址一样的\r\n        has(key)\r\n            返回一个布尔值，表示某个键是否在当前 Map 对象之中。\r\n        delete(key)\r\n            删除某个键，返回true。如果删除失败，返回false。\r\n        clear()\r\n            清除所有成员，没有返回值。\r\n\r\n*/\nvar map1 = new Map();\nmap1.set([\"a\"], 1);\nconsole.log(map1.get([\"a\"])); //不是同一个引用地址了 这里相当于重新定义了一个数组 开辟了一个新的内存\n\nvar arr = [\"a\"];\nconsole.log(map1.set(arr, 1)); //Map的键实际上是跟内存地址绑定的\nconsole.log(map1.get(arr)); //arr内存地址一样 所以返回1\nconsole.log(map1.arr); //undefined  通过.调用=> map1[\"arr\"];\n// console.log(map1.[\"a\"]); 语法错误\nconsole.log(map1[arr]); //也是不行 只能通过get 方法获取了\n\nconsole.log(map1.size); //2\nconsole.log(map1.has(arr), map1.has([\"a\"]));\nconsole.log(map1.delete([\"a\"]));\nconsole.log(map1.clear());\nconsole.log(map1);\n\n/* \r\n    可以通过forEach遍历\r\n*/\n\nmap1.forEach(function () {\n    console.log(1);\n});\nconsole.dir(map1.forEach);\n//# sourceMappingURL=10、Map.js.map"]}