{"version":3,"sources":["..\\..\\..\\es6\\js\\12、Class.js"],"names":["Test","x","y","test","console","log","add","subtract","prototype","Object","assign","test2","__proto__","getPrototypeOf","Test1","value","test1","prop","Test2"],"mappings":";;;;;;AAAA;;;;;;;;;;;;IAYMA,I;AACF,oBAAc;AAAA;;AACV,aAAKC,CAAL,GAAS,CAAT;AACA,aAAKC,CAAL,GAAS,CAAT;AACA;AACA;AACH;;;;8BACK;AACF,mBAAO,KAAKD,CAAL,GAAS,KAAKC,CAArB;AACH;;;mCACU;AACP,mBAAO,KAAKA,CAAL,GAAS,KAAKD,CAArB;AACH;;;;;;AAEL,IAAIE,OAAO,IAAIH,IAAJ,EAAX;AACAI,QAAQC,GAAR,CAAYF,KAAKF,CAAjB,EAAoBE,KAAKD,CAAzB;AACAE,QAAQC,GAAR,CAAYF,KAAKG,GAAL,EAAZ;AACAF,QAAQC,GAAR,CAAYF,KAAKI,QAAL,EAAZ;AACAH,QAAQC,GAAR,CAAYL,KAAKQ,SAAjB;;AAEA;;;;;;;AAOAC,OAAOC,MAAP,CAAcV,KAAKQ,SAAnB,EAA8B;AAC1BL,QAD0B,kBACnB;AACHC,gBAAQC,GAAR,CAAY,aAAZ;AACH,KAHyB;AAI1BM,SAJ0B,mBAIlB;AACJP,gBAAQC,GAAR,CAAY,aAAZ;AACH;AANyB,CAA9B;AAQAD,QAAQC,GAAR,CAAYF,KAAKS,SAAjB,E,CAA6B;AAC7BR,QAAQC,GAAR,CAAYI,OAAOI,cAAP,CAAsBV,IAAtB,CAAZ,E,CAA0C;;AAE1C;;;;;IAIMW,K;;;;;;;sCACY,CAAE;;;4BACL;AACP,mBAAO,MAAP;AACH,S;0BACQC,K,EAAO;AACZ,mBAAOA,KAAP;AACH;;;;;;AAEL,IAAIC,QAAQ,IAAIF,KAAJ,EAAZ;AACAV,QAAQC,GAAR,CAAYW,MAAMC,IAAlB;AACAb,QAAQC,GAAR,CAAYW,MAAMC,IAAN,GAAa,MAAzB;;AAEA;;;;;;;;IAOMC,K;AACF,qBAAc;AAAA;AAAE;;;;8BACH;AACTd,oBAAQC,GAAR,CAAY,4CAA4C,IAAxD;AACH;;;;;;AAEL,IAAIM,QAAQ,IAAIO,KAAJ,EAAZ;AACAA,MAAMZ,GAAN;AACA;;AAEA;;;;;;;;AAQA;;;;;;;;;;;;AAYA;;;;;AAKA","file":"12、Class.js","sourcesContent":["/* \r\n    传统语法中,创建一个实例对象是通过构造函数(类)生成的。\r\n    为了跟接近传统语言的语法,ES6中添加了Class关键字  可以定义一个类\r\n    也是通过new创建实例对象的  但是class类 只能通过new来使用 直接使用会报错\r\n\r\n    通过class 定义一个类\r\n    这个类同样有prototype属性  其内部的方法都是定义在Test类的prototype对象上\r\n    这个类里面有一个方法是constructor 相当于是 ES5的Test构造函数 该方法返回的就是实例对象 同样该方法可以自定义返回一个对象\r\n    该方法只要new了这个类 就自动调用这个方法 如果没有显式定义这个方法 那么会被默认添加\r\n\r\n    在类里面定义方法 不需要function 可以直接使用对象方法的简写法  并且方法与方法之间不能用,隔开 否则报错\r\n*/\nclass Test {\n    constructor() {\n        this.x = 1;\n        this.y = 2;\n        // return \"string\" 没效果\n        // return {} 跟旧语法一样 只能返回一个对象 不是对象类型的都不会返回出去\n    }\n    add() {\n        return this.x + this.y;\n    }\n    subtract() {\n        return this.y - this.x;\n    }\n}\nlet test = new Test();\nconsole.log(test.x, test.y);\nconsole.log(test.add());\nconsole.log(test.subtract());\nconsole.log(Test.prototype);\n\n/* \r\n    Object.assign方法可以很方便地一次向类添加多个方法\r\n    Object.assign(需要添加方法的原型对象,{\r\n        fn1(){},\r\n        fn2(){}\r\n    })\r\n*/\nObject.assign(Test.prototype, {\n    test() {\n        console.log(\"第一次测试assign\");\n    },\n    test2() {\n        console.log(\"第二次测试assign\");\n    }\n});\nconsole.log(test.__proto__); //实例对象同样可以通过浏览器提供的__proto__属性访问自己构造函数的原型对象\nconsole.log(Object.getPrototypeOf(test)); //但是ES6中提供了方法 就不建议使用浏览器提供的隐式属性了\n\n/* \r\n    取值函数（getter）和存值函数（setter）\r\n    还不知道有什么用\r\n*/\nclass Test1 {\n    consturctor() {}\n    get prop() {\n        return \"取值函数\";\n    }\n    set prop(value) {\n        return value;\n    }\n}\nlet test1 = new Test1();\nconsole.log(test1.prop);\nconsole.log(test1.prop = \"存值函数\");\n\n/* \r\n    类相当于实例的原型 因为类里面的方法都是定义在prototype上的  所以只要是通过这个类new出来的实例 都可以调用类上的方法(继承)\r\n    但是如果我们希望这个类里的某些方法不被继承 那么就可以在方法前 加上static关键字 表示该方法不被继承 只能通过类来调用\r\n    称之为 静态方法  \r\n    那么如果在静态方法上使用this 可想而知 静态方法只能是类调用 所以this自然就指向了类\r\n \r\n*/\nclass Test2 {\n    constructor() {}\n    static add() {\n        console.log(\"方法前加上了static 那么就是静态方法 只能类调用,并且this指向的是类\" + this);\n    }\n}\nlet test2 = new Test2();\nTest2.add();\n// test2.add();会报错 test2.add is not a function\n\n/* \r\n    实例属性有一个新写法\r\n    就是写在类的顶部\r\n    好处就是一目了然的看到类有哪些属性\r\n\r\n    同时还有静态属性 也是通过static定义的 因为是静态属性 所以只能类自己调用 那么类里面的方法实际上都是实例对象调用的\r\n    所以方法里面也不能使用\r\n*/\n/* class Test3 {  babel不给转义成es5 但是浏览器可以\r\n    x = 1;\r\n    y = 2;\r\n    static z = 3;\r\n    add() {\r\n        return this.x + this.y\r\n    }\r\n}\r\nlet test3 = new Test3();\r\nconsole.log(test3.add());\r\nconsole.log(test3.x, test3.y, test3.z); */\n\n/* \r\n    私有方法和私有属性的解决方案:\r\n        在以往都是通过 _变量来表示这个是私有属性或方法 但实际上是给程序员看的 本质上还是可以在外部调用的\r\n        那么现在有一个新的提案 就是在私有属性或方法前面 添加一个#表示是私有的\r\n*/\n/* \r\n    class Test4 {\r\n        #a;\r\n    }\r\n    let test4 = new Test4();\r\n    console.log(test4.x); \r\n    浏览器报错呀 不能测试呀 具体看ES6手册呀\r\n*/"]}