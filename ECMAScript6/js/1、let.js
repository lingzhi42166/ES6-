/*
* let用来声明变量
* 与var的区别:
*   - let只是在声明的代码块内有效
*   - 不存在变量提升,也就是let声明的变量 必须要在声明后使用 否则报错
*   - 暂时性死区:
*       只要块级作用域内通过let声明了这个变量,那么这个变量就绑定了这个区域
*       不受外部影响。通俗来讲 就是在预解析的时候 已经声明了这个let变量
*       因为let不存在变量提升 所以如果全局作用域有一个变量名和块级作用域内let声明的变量名一样的话
*       即使在块级作用域内 在let声明这个变量前面 使用这个变量 是会报错的。
*       然后再理解一下只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
*
*    - 不允许在同一个作用域内重复声明同一个变量名 否则报错。
*       因此需要注意的是 es5中 在函数内部同一个作用域内 喜欢用同样的参数名声明一个变量保存参数值的 在let或者const就会报错
*
*    - let实际上为 JavaScript 新增了块级作用域。
*
*    - ES6 的块级作用域必须有大括号
* */
{
    //let实际上就是为javascript新增块级作用域
    let a = "a";//只在当前作用域生效
    var b = "b";
}
// console.log(a);//a is not defined
console.log(b);//b


//for循环的不同
/*
*在es5中 只有全局作用域和函数作用域
* 所以for循环中通过var声明的变量是全局的
*
* 那么es6中是有块级作用域的 并且在for循环中通过let声明的循环变量只在本轮循环中生效
* 每一次循环 都是一个新的变量  JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。
*
* 并且在es6中 for循环还有一个特别之处  就是设置循环变量的那一部分是父作用域,循环体内又是一个单独的子作用域
* 所以循环变量部分声明的变量 和循环体内声明的变量名一样的话 是不冲突的 因为作用域不同
* */
var arr = [];
var arr2 = [];
for(var i = 0; i<10; i++){
    arr[i] = function(){
        console.log(i);
    }
}
arr[1]();//10
for(let i = 0; i<10; i++){//for循环父作用域 let i = 每次都是新声明 值从javascript引擎中取
    //for循环子作用域
    arr2[i] = function(){
        console.log(i);
    }
    /*
        这个函数的作用域链
        首先在声明的时候  0:for的子作用域
                        1:for循环的父作用域 i已经声明赋值在这里了
                        然后这个函数内保存在了arr2[i]里面
                        其作用域链也就被保存出去了
                        闭包

        执行的时候       0:fnAO   自己作用域没有i 往上级作用域找
                        1:for的子作用域
                        2:for循环的父作用域 有i 取值


    */
}
arr2[1]();//1


//作用域
for(let i = 0; i<10; i++){//这里的i变量是for循环的父作用域内声明的 与全局作用域无关
    let i = "这是子作用域的变量";
    console.log(i);
}

//暂时性死区
let a = 1;
function del() {
    console.log(a);// a is not defined
    let a = 2;//变量a已经绑定了这个作用域 并且let规定不允许在变量声明前使用变量
}
// del();

//不允许重复声明
function repeat(){
    // let a = 1;
    // let a = 2;
}
//repeat();//Identifier 'a' has already(已经) been(被) declared(声明 宣布) 已经声明

//ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。
if(true){
    function test(){
        // document.body.innerHTML = 1;
    }
}
test();
/*  ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。
    ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。
    但是如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。
    为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。
    允许在块级作用域内声明函数。
    函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
    同时，函数声明还会提升到所在的块级作用域的头部。
    注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。
 */


//ES6 的块级作用域必须有大括号
// if(true) let a = "a";  报错 词法声明不能出现在单语句上下文中

/*
    在浏览器中 顶层对象就是window对象 在 Node 指的是global对象
    ES5中顶层对象的属性赋值与全局变量的赋值 全局函数的声明，是同一件事。
    这被认为是javascript设计上最大的败笔。
    ES6为了改变这一点,同时要保持兼容性,使var命令和function命令声明的全局变量，依旧是顶层对象的属性
    但是let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。
    也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。
*/
var b = 1;
function test(){

}
let c = 1;
console.log(window);//b 和 test函数在window对象的属性里 而c并不在 已经脱钩




